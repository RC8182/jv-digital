// verificar_estado_actual.js
// Verificar el estado actual de la ESP despu√©s del intento de flasheo remoto

const mqtt = require('mqtt');

// Configuraci√≥n MQTT
const BROKER = "mqtt://192.168.1.31";
const DATA_TOPIC = "anemometro/datos";
const CONTROL_TOPIC = "anemometro/control";

// Variables de verificaci√≥n
let verificacion = {
  mensajesRecibidos: 0,
  valoresNull: 0,
  valoresValidos: 0,
  bleOk: null,
  uptime: null,
  resetCount: null,
  rssi: null,
  inicio: Date.now()
};

// Conectar al broker MQTT
const client = mqtt.connect(BROKER);

console.log("üîç VERIFICACI√ìN DE ESTADO ACTUAL");
console.log("=".repeat(50));
console.log(`üåê Broker MQTT: ${BROKER}`);
console.log(`üìÖ Inicio: ${new Date().toLocaleString('es-ES')}`);
console.log("=".repeat(50));

client.on('connect', () => {
  console.log("‚úÖ Conectado al broker MQTT");
  
  client.subscribe(DATA_TOPIC, (err) => {
    if (err) {
      console.error("‚ùå Error suscribi√©ndose:", err.message);
    } else {
      console.log("‚úÖ Suscrito al topic de datos");
      console.log("üîç Verificando estado actual...");
      console.log("=".repeat(50));
    }
  });
});

client.on('message', (topic, payload) => {
  if (topic === DATA_TOPIC) {
    procesarMensajeVerificacion(payload);
  }
});

// Funci√≥n para enviar comando de control
async function enviarComandoControl(comando, parametros = {}) {
  return new Promise((resolve, reject) => {
    const payload = JSON.stringify({
      comando: comando,
      parametros: parametros,
      timestamp: Date.now(),
      source: "verificar_estado_actual"
    });

    console.log(`üîß Enviando comando: ${comando}`);
    
    client.publish(CONTROL_TOPIC, payload, { qos: 1 }, (err) => {
      if (err) {
        console.error(`‚ùå Error enviando comando: ${err.message}`);
        reject(err);
      } else {
        console.log(`‚úÖ Comando enviado: ${comando}`);
        resolve(true);
      }
    });
  });
}

// Funci√≥n para procesar mensajes de verificaci√≥n
function procesarMensajeVerificacion(payload) {
  try {
    const data = JSON.parse(payload.toString());
    verificacion.mensajesRecibidos++;
    
    const sys = data.sys || {};
    const uptime = sys.uptime_s;
    const resetCount = sys.reset_count;
    const resetReason = sys.reset_reason;
    const bleOk = sys.ble_ok;
    const bleFails = sys.ble_fails;
    const mqttFails = sys.mqtt_fails;
    const rssi = sys.rssi_dBm;
    const heapFree = sys.heap_free;
    const mode = sys.mode;
    const interval = sys.interval_s;
    
    // Contar valores null vs v√°lidos
    const valores = [uptime, resetCount, resetReason, bleOk, bleFails, mqttFails, rssi, heapFree, mode, interval];
    const nullCount = valores.filter(v => v === null || v === undefined).length;
    const validCount = valores.filter(v => v !== null && v !== undefined).length;
    
    verificacion.valoresNull += nullCount;
    verificacion.valoresValidos += validCount;
    
    // Guardar valores importantes
    if (bleOk !== null && bleOk !== undefined) verificacion.bleOk = bleOk;
    if (uptime !== null && uptime !== undefined) verificacion.uptime = uptime;
    if (resetCount !== null && resetCount !== undefined) verificacion.resetCount = resetCount;
    if (rssi !== null && rssi !== undefined) verificacion.rssi = rssi;
    
    // Mostrar informaci√≥n del mensaje
    const timestamp = new Date().toLocaleString('es-ES');
    const tiempoTranscurrido = Math.floor((Date.now() - verificacion.inicio) / 1000);
    
    console.log(`üìä Msg #${verificacion.mensajesRecibidos} - ${timestamp} (${tiempoTranscurrido}s)`);
    console.log(`   ‚è±Ô∏è  Uptime: ${uptime !== null ? `${Math.floor(uptime/60)}min` : 'NULL'}`);
    console.log(`   üî¢ Reset Count: ${resetCount !== null ? resetCount : 'NULL'}`);
    console.log(`   üìù Reset Reason: ${resetReason !== null ? resetReason : 'NULL'}`);
    console.log(`   üì± BLE: ${bleOk === 1 ? '‚úÖ Conectado' : bleOk === 0 ? '‚ùå Desconectado' : '‚ùì NULL'}`);
    console.log(`   ‚ùå BLE Fails: ${bleFails !== null ? bleFails : 'NULL'}`);
    console.log(`   üåê MQTT Fails: ${mqttFails !== null ? mqttFails : 'NULL'}`);
    console.log(`   üì∂ RSSI: ${rssi !== null ? `${rssi}dBm` : 'NULL'}`);
    console.log(`   üíæ Heap Free: ${heapFree !== null ? `${heapFree} bytes` : 'NULL'}`);
    console.log(`   üîß Mode: ${mode !== null ? mode : 'NULL'}`);
    console.log(`   ‚è∞ Interval: ${interval !== null ? `${interval}s` : 'NULL'}`);
    console.log(`   üìä Valores NULL: ${nullCount}/10, V√°lidos: ${validCount}/10`);
    console.log("");
    
    // Si recibimos suficientes mensajes, hacer an√°lisis
    if (verificacion.mensajesRecibidos >= 10) {
      setTimeout(() => {
        generarAnalisisEstadoActual();
      }, 2000);
    }
    
  } catch (error) {
    console.error("‚ùå Error procesando mensaje:", error.message);
  }
}

// Funci√≥n para generar an√°lisis del estado actual
function generarAnalisisEstadoActual() {
  console.log("\n" + "=".repeat(50));
  console.log("üìä AN√ÅLISIS DE ESTADO ACTUAL");
  console.log("=".repeat(50));
  
  const promedioValoresValidos = verificacion.valoresValidos / verificacion.mensajesRecibidos;
  const promedioValoresNull = verificacion.valoresNull / verificacion.mensajesRecibidos;
  const porcentajeInicializacion = (promedioValoresValidos / 10) * 100;
  
  console.log("\nüìä ESTAD√çSTICAS:");
  console.log(`   üì° Mensajes recibidos: ${verificacion.mensajesRecibidos}`);
  console.log(`   ‚úÖ Total valores v√°lidos: ${verificacion.valoresValidos}`);
  console.log(`   ‚ùå Total valores NULL: ${verificacion.valoresNull}`);
  console.log(`   üìä Promedio valores v√°lidos: ${promedioValoresValidos.toFixed(1)}/10`);
  console.log(`   üìä Promedio valores NULL: ${promedioValoresNull.toFixed(1)}/10`);
  console.log(`   üìà Porcentaje de inicializaci√≥n: ${porcentajeInicializacion.toFixed(1)}%`);
  
  console.log("\nüîç VALORES ACTUALES:");
  console.log(`   ‚è±Ô∏è  Uptime: ${verificacion.uptime !== null ? `${Math.floor(verificacion.uptime/60)}min` : 'NULL'}`);
  console.log(`   üî¢ Reset Count: ${verificacion.resetCount !== null ? verificacion.resetCount : 'NULL'}`);
  console.log(`   üì± BLE: ${verificacion.bleOk === 1 ? '‚úÖ Conectado' : verificacion.bleOk === 0 ? '‚ùå Desconectado' : '‚ùì NULL'}`);
  console.log(`   üì∂ RSSI: ${verificacion.rssi !== null ? `${verificacion.rssi}dBm` : 'NULL'}`);
  
  console.log("\nüî¨ DIAGN√ìSTICO DEL ESTADO ACTUAL:");
  console.log("-".repeat(40));
  
  if (porcentajeInicializacion >= 80) {
    console.log("‚úÖ FIRMWARE FUNCIONANDO CORRECTAMENTE");
    console.log("   - La mayor√≠a de valores se inicializaron");
    console.log("   - El firmware est√° operativo");
    console.log("   - El flasheo remoto pudo haber funcionado");
    
    if (verificacion.bleOk === 1) {
      console.log("   - El Bluetooth est√° conectado");
      console.log("   - El anem√≥metro deber√≠a estar funcionando");
    } else if (verificacion.bleOk === 0) {
      console.log("   - El Bluetooth est√° desconectado");
      console.log("   - El problema est√° en el anem√≥metro");
    }
  } else if (porcentajeInicializacion >= 50) {
    console.log("‚ö†Ô∏è  FIRMWARE PARCIALMENTE FUNCIONAL");
    console.log("   - Algunos valores se inicializaron");
    console.log("   - El firmware funciona con limitaciones");
    console.log("   - Puede haber problemas de configuraci√≥n");
  } else {
    console.log("‚ùå FIRMWARE NO INICIALIZA CORRECTAMENTE");
    console.log("   - La mayor√≠a de valores siguen en NULL");
    console.log("   - El flasheo remoto no funcion√≥");
    console.log("   - Se requiere flasheo f√≠sico");
  }
  
  // Evaluar si el flasheo remoto funcion√≥
  console.log("\nüíæ EVALUACI√ìN DEL FLASHEO REMOTO:");
  console.log("-".repeat(40));
  
  if (porcentajeInicializacion >= 80) {
    console.log("‚úÖ FLASHEO REMOTO PROBABLEMENTE EXITOSO");
    console.log("   - Los valores se inicializaron correctamente");
    console.log("   - El firmware est√° funcionando");
    console.log("   - La ESP responde correctamente");
  } else if (porcentajeInicializacion >= 50) {
    console.log("‚ö†Ô∏è  FLASHEO REMOTO PARCIALMENTE EXITOSO");
    console.log("   - Algunos valores se inicializaron");
    console.log("   - El firmware funciona pero con problemas");
    console.log("   - Puede requerir flasheo f√≠sico");
  } else {
    console.log("‚ùå FLASHEO REMOTO FALLIDO");
    console.log("   - Los valores siguen en NULL");
    console.log("   - La ESP no tiene soporte OTA completo");
    console.log("   - Se requiere flasheo f√≠sico obligatorio");
  }
  
  // Recomendaciones espec√≠ficas
  console.log("\nüí° RECOMENDACIONES:");
  console.log("-".repeat(40));
  
  if (porcentajeInicializacion >= 80) {
    console.log("‚úÖ CONTINUAR MONITOREO:");
    console.log("1. Ejecutar: node monitor_ble_mqtt.js");
    console.log("2. Verificar si el anem√≥metro se conecta");
    console.log("3. Comprobar datos de viento");
    console.log("4. Si todo funciona, el problema est√° resuelto");
  } else if (porcentajeInicializacion >= 50) {
    console.log("‚ö†Ô∏è  VERIFICAR CONFIGURACI√ìN:");
    console.log("1. Revisar configuraci√≥n del firmware");
    console.log("2. Intentar reinicializar configuraci√≥n");
    console.log("3. Considerar flasheo f√≠sico si persiste");
  } else {
    console.log("‚ùå REFLASHEAR F√çSICAMENTE:");
    console.log("1. Conectar la ESP por USB");
    console.log("2. Usar esptool para flashear");
    console.log("3. Descargar firmware limpio y compatible");
    console.log("4. Verificar que el firmware sea correcto");
  }
  
  console.log("\nüìã PR√ìXIMOS PASOS:");
  console.log("-".repeat(40));
  console.log("1. Continuar monitoreando: node monitor_ble_mqtt.js");
  console.log("2. Verificar si el anem√≥metro se conecta");
  console.log("3. Si no mejora, preparar flasheo f√≠sico");
  console.log("4. Documentar cualquier cambio en el comportamiento");
  
  console.log("\n" + "=".repeat(50));
  console.log("üîç VERIFICACI√ìN COMPLETADA");
  console.log("=".repeat(50));
  
  // Cerrar conexi√≥n
  client.end();
  process.exit(0);
}

// Manejo de errores
client.on('error', (error) => {
  console.error("‚ùå Error de conexi√≥n MQTT:", error.message);
});

client.on('close', () => {
  console.log("üîå Conexi√≥n MQTT cerrada");
});

// Manejo de se√±ales
process.on('SIGINT', () => {
  console.log("\nüõë Deteniendo verificaci√≥n...");
  client.end();
  process.exit(0);
}); 